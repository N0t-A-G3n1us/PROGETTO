<!--

There are many ways to keep the score in a game, we will show you how to write a score onto the canvas.

1) First make a score component

2) The syntax for writing text on a canvas element is different from drawing a rectangle. Therefore we must call the component constructor using an additional argument, telling the constructor that this component is of type "text".
In the component constructor we test if the component is of type "text", and use the fillText method instead of the fillRect method

3) At last we add some code in the updateGameArea function that writes the score onto the canvas. We use the frameNo property to count the score

-->

<!DOCTYPE html>
<html>
	<head>
		<link rel = "prev" type="text/html" >
        
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        
        <style >
            canvas {
                border:1px solid #d3d3d3;
                background-color: grey;
                margin-left: 600px;
                margin-top: 200px;
                border-color: black;
            }
        </style>
        <script type = "text/javascript" language = "javascript">

        //var doc = document.querySelector('link[rel="import"]').import;

        //var nome = doc.myGameForm.NomeUtente.value;

        var myGamePiece;
        var myObstacles=[]; //array di component ostacoli
        var myScore;
        var id= window.location.search.substr(1).toString().split("=")[1];
        var myId;


        function startGame() {
        	//window.alert("NomeUtente: " + nome);
            myGamePiece = new component(60, 30, "carAbove.png", 10, 120, "image");
            myGamePiece.speedX = 0;
            myGamePiece.speedY = 0;
            
            myObstacle = new component(10,200,"black",300,120);
            
            myId=new component("10px", "Id", "red", 250, 100, "text");
            
            myScore = new component("30px", "Consolas", "red", 280, 40, "text"); // Consolas è il font
           
            myGameArea.start();
        }

        var myGameArea = {
            canvas : document.createElement("canvas"),
            start : function() {
                this.canvas.width = 480;
                this.canvas.height = 270;
                this.context = this.canvas.getContext("2d");
                document.body.insertBefore(this.canvas, document.body.childNodes[0]);
                this.frameNo = 0; // <--
                this.interval = setInterval(updateGameArea, 20);
                
                //VANNO AGGIUNTI GLI EVENT LISTENER PER KEYBOARD INPUT
                //Qui versione: Multiple Keys Pressed, per permettere di muoversi in diagonale
                // IL PROBLEMA STA QUA
                window.addEventListener('keydown', function (e) {
                    myGameArea.keys = (myGameArea.keys || []);  // se stesso o nuovo array
                    myGameArea.keys[e.keyCode] = true;  //bottone premuto
                })
                window.addEventListener('keyup', function (e) {
                    myGameArea.keys[e.keyCode] = false; //bottone non piu premuto
                })
            },
            clear : function(){
                this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            },
            stop: function() {
                clearInterval(this.interval)
            }
        }
            
        // ritorna true se il corrente frameNo corrisponde a n
        function everyInterval(n) {
            if ((myGameArea.frameNo/ n) % 1 == 0) return true;
            return false;   
        }


        function component(width,height,color,x,y, type){ //costruttore
            this.type = type;
            if (type == "image") {
				this.image = new Image();
				this.image.src = color;
			}
            this.width = width;
            this.height = height;
            this.speedX = 0;    //sono usati come indicatori di velocita
            this.speedY = 0;
            this.x = x;
            this.y = y; 
            
            this.update = function() {
                ctx = myGameArea.context;
                if (type == "image") {
					ctx.drawImage(this.image,
					this.x,
					this.y,
					this.width, this.height);
                }
                else if(this.type == "text"){
                    ctx.font = this.width + " " + this.height;
                    ctx.fillStyle = color;
                    ctx.fillText(this.text, this.x, this.y);
                }
                else{
                    ctx.fillStyle = color;
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }
            
            this.newPos = function() {  //cambia la posizione del component
                //lavorando su speedX e speedY 
                this.x += this.speedX;
                this.y += this.speedY;
            }
            
            this.crashWith = function(otherobj) {
                var myleft = this.x;
                var myright = this.x + (this.width);
                var mytop = this.y;
                var mybottom = this.y + (this.height);
                var otherleft = otherobj.x;
                var otherright = otherobj.x + (otherobj.width);
                var othertop = otherobj.y;
                var otherbottom = otherobj.y + (otherobj.height);
                var crash = true;   // presuppongo collisione
                if ((mybottom < othertop) ||    //verifico se non c è stata
                       (mytop > otherbottom) ||
                       (myright < otherleft) ||
                       (myleft > otherright)) {
                   crash = false;
                }
                return crash;
            }

            this.crashWithBorder = function(h){
            	var myleft = this.x;
                var myright = this.x + (this.width);
                var mytop = this.y;
                var mybottom = this.y + (this.height);
                var othertop = h;
                var otherbottom = 0;
                var crash = true;   // presuppongo collisione
                if ((mybottom < othertop) ||    //verifico se non c è stata
                       (mytop > otherbottom) 
                       ) {
                   crash = false;
                }
                console.log(h)

                return crash;

            }
            
        }

        function updateGameArea() { //va chiamata periodicamente
            
            var x, height, gap, minHeight, maxHeight, minGap, maxGap;
            for (i=0; i< myObstacles.length; i++) {
                //controllo : crash con ostacolo myObstacle[i] ?
                if (myGamePiece.crashWith(myObstacles[i])) {
                    //AVVENUTO CRASH CON OSTACOLO
                    window.alert("GAME OVER");
                    window.alert("YOUR SCORE IS: " + myGameArea.frameNo);
                    myGameArea.stop();
                    //bisogna far in modo di farlo restartare senza che si muova all avvio
                    /*
                    myGameArea.clear();
                    myGamePiece.newPos();
                    myObstacles = [];
                    startGame();
                    */
                    window.location.reload();
                }
            }

            if(myGamePiece.crashWithBorder(myGameArea.canvas.height)){
            	//AVVENUTO CRASH CON OSTACOLO
                    window.alert("GAME OVER Bordo");
                    window.alert("YOUR SCORE IS: " + myGameArea.frameNo);
                    myGameArea.stop();
                    //bisogna far in modo di farlo restartare senza che si muova all avvio
                    /*
                    myGameArea.clear();
                    myGamePiece.newPos();
                    myObstacles = [];
                    startGame();
                    */
                    window.location.reload();
            }

            myGameArea.clear();
            myGameArea.frameNo +=1;
            
            if (myGameArea.frameNo == 1 || everyInterval(150)) {
                x = myGameArea.canvas.width;
                // Per ostacoli di dimensione random
                minHeight = 20;
                maxHeight = 200;
                height = Math.floor(Math.random()*(maxHeight-minHeight+1)+minHeight);
                minGap = 50;
                maxGap = 200;
                gap = Math.floor(Math.random()*(maxGap-minGap+1)+minGap);
                myObstacles.push(new component(10, height, "green", x, 0));
                myObstacles.push(new component(10, x - height - gap, "green", x, height + gap));
                //y = myGameArea.canvas.height - 200
                myObstacles.push(new component(10, 200, "green", x, y));
            }
            
            
            myGamePiece.speedX = 0;
            myGamePiece.speedY = 0;
            //movimenti: W,A,S,D
            if (myGameArea.keys && myGameArea.keys[65])
                {myGamePiece.speedX = -0.5; }
            if (myGameArea.keys && myGameArea.keys[68]) 
                {myGamePiece.speedX = 0.5; }
            if (myGameArea.keys && myGameArea.keys[87]) 
                {myGamePiece.speedY = -1.5; }
            if (myGameArea.keys && myGameArea.keys[83]) 
                {myGamePiece.speedY = 1.5; }
            
            for (i = 0; i < myObstacles.length; i += 1) {
				if(myGameArea.frameNo<500)
					myObstacles[i].x += -1;	//velocita iniziale
                else
					myObstacles[i].x += -(myGameArea.frameNo/500);

                myObstacles[i].newPos();
                myObstacles[i].update();
            }
            myScore.text = "Score: " + myGameArea.frameNo;
            myId.text=id;
            myId.update();
            myScore.update();
            myGamePiece.newPos();
            myGamePiece.update();
            
               
        }
        //per fermare il component (a che serve???)
        </script>
    </head>
    <body onload = "startGame();">
</html>
